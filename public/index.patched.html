<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>EPUB Reader — demo (stroke icons &amp; dark-mode text; 10px bar)</title>
<style>
:root{
  --bg:#fff; --fg:#111; --muted:#666; --accent:#800020;
  --bar:#555; --pin:#333;
  --reader-font:ui-sans-serif,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
  --base:27px; --ui:16px;
}
:root[data-theme="dark"]{ --bg:#0b0b0b; --fg:#f1f1f1; --muted:#a0a0a0; --bar:#555; --pin:#333; }
@media (prefers-color-scheme: dark){
  :root:not([data-theme="light"]){ --bg:#0b0b0b; --fg:#f1f1f1; --muted:#a0a0a0; --bar:#555; --pin:#333; }
}
*{box-sizing:border-box}
html,body{min-height:100%}
body{margin:0;background:var(--bg);color:var(--fg);font:var(--base)/1.6 var(--reader-font);overflow-x:hidden}
.topbar{position:fixed;top:0;left:0;right:0;z-index:50;background:rgba(255,255,255,.86);backdrop-filter:saturate(180%) blur(8px);border-bottom:1px solid #e6e6e6;font-size:var(--ui)}
:root[data-theme="dark"] .topbar{background:rgba(16,16,16,.7);border-bottom-color:#272727}
.topbar-inner{display:flex;align-items:center;gap:12px;padding:10px 20px;padding-left:calc(20px + env(safe-area-inset-left));padding-right:calc(20px + env(safe-area-inset-right));}
.title{flex:1 1 auto;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:600}
.icons{display:flex;gap:10px}
.icon-btn{width:32px;height:32px;display:grid;place-items:center;border:none;background:none;color:var(--fg);cursor:pointer;border-radius:8px}
.icon-btn:hover{background:rgba(0,0,0,.06)}
:root[data-theme="dark"] .icon-btn:hover{background:rgba(255,255,255,.08)}
.icon-btn svg{display:block;width:22px;height:22px}

/* Toolbar icon strokes */
.icon-stroke{fill:none;stroke:currentColor;stroke-width:2;stroke-linecap:round;stroke-linejoin:round}

/* SVG text for Aa / A+ / A- should follow theme color */
.uiText{font-family:var(--reader-font);font-weight:700;font-size:16px;text-anchor:middle;dominant-baseline:central;fill:currentColor}

/* Bookmark stays as before */
.bookmark svg path{fill:none;stroke:currentColor;stroke-width:2}
.bookmark.active svg path{fill:var(--accent);stroke:var(--accent)}

.icons.settings{display:none}.settings-mode .icons.default{display:none}.settings-mode .icons.settings{display:flex}

/* Progress bar now 10px; pin 10px high, 5px wide */
.progress-wrap{position:fixed;left:0;right:0;height:10px;z-index:49;pointer-events:none top: var(--progress-top, 0px);}
#progressBar{height:10px;position:relative;pointer-events:auto}
.progress-fill{position:absolute;left:0;top:0;height:100%;width:0;background:var(--bar)}
.pin{position:absolute;top:0;width:5px;height:10px;background:var(--pin);transform:translateX(-50%);cursor:pointer}

.viewer-wrap{width:100%;margin:12px 0 80px}
#viewer{width:100%}
#viewer p{font-weight:450;margin:28px 20px}

/* Prevent horizontal scroll in the reader */
.viewer-wrap, #viewer { overflow-x: hidden; }
#viewer section { overflow-x: clip; }
/* Constrain media */
#viewer :where(img, svg, video, iframe, canvas){ max-width:100% !important; height:auto; }
#viewer figure, #viewer table, #viewer div, #viewer section, #viewer article { box-sizing:border-box; max-width:100%; }
/* Wrap long code/links */
#viewer pre, #viewer code { white-space: pre-wrap; word-wrap: break-word; }
#viewer p, #viewer li, #viewer a { overflow-wrap: anywhere; word-break: break-word; }
/* Reset any author CSS that forces widths */
#viewer [style*="width:"] { max-width:100% !important; }
</style>
<style>

/* === Annotate UI (from model; UI-only) === */
.icons.annotate{display:none}
.annotate-mode .icons.default{display:none}
.annotate-mode .icons.settings{display:none}
.annotate-mode .icons.annotate{display:flex}

/* Icons within annotate bar */

/* Chip visuals */
.annotate-color{width:16px;height:16px;border-radius:50%;border:1px solid #b5b5b5;display:inline-block}
.annotate-color.y{background:#FDF5A8;}
.annotate-color.g{background:#AFD5AB;}
.annotate-color.b{background:#9CC8F5;}
.annotate-color.pk{background:#EFBECF;}
.annotate-color.p{background:#C9A2E6;}
:root[data-theme="dark"] .annotate-color.y{background:rgba(253,245,168,0.4);}
:root[data-theme="dark"] .annotate-color.g{background:rgba(175,213,171,0.4);}
:root[data-theme="dark"] .annotate-color.b{background:rgba(156,200,245,0.4);}
:root[data-theme="dark"] .annotate-color.pk{background:rgba(239,190,207,0.4);}
:root[data-theme="dark"] .annotate-color.p{background:rgba(201,162,230,0.4);}

/* Dictionary (Aa) icon visuals */
.dict-icon{width:22px;height:22px}
.dict-icon rect{fill:none;stroke:currentColor;stroke-width:2;rx:3;ry:3;vector-effect:non-scaling-stroke}
.dict-icon text{font:700 10px/1 var(--reader-font);fill:currentColor;dominant-baseline:middle;text-anchor:middle}

/* Underline (Safari-safe) */
.gloss{border-bottom:none;text-decoration-line:underline;text-decoration-style:dotted;text-decoration-color:currentColor;text-decoration-thickness:0.12em;text-underline-offset:0.22em;-webkit-text-decoration-line:underline;-webkit-text-decoration-style:dotted;-webkit-text-decoration-color:currentColor;-webkit-text-decoration-thickness:0.12em}



/* Underline (Safari-safe) */


/* Highlights */
.hl-y{background:#FDF5A8;}
.hl-g{background:#AFD5AB;}
.hl-b{background:#9CC8F5;}
.hl-pk{background:#EFBECF;}
.hl-p{background:#C9A2E6;}
[data-theme="dark"] .hl-y{background:rgba(253,245,168,0.4);}
[data-theme="dark"] .hl-g{background:rgba(175,213,171,0.4);}
[data-theme="dark"] .hl-b{background:rgba(156,200,245,0.4);}
[data-theme="dark"] .hl-pk{background:rgba(239,190,207,0.4);}
[data-theme="dark"] .hl-p{background:rgba(201,162,230,0.4);}

</style>
<style>
/* === Drawer (base) === */
#topDrawer { top: 0;
  position: fixed;
  left: 0; right: 0;
  z-index: 48;
  height: 150px;
  pointer-events: none;
  transform: translateY(-150px);
  transition: transform .25s ease;
}
.drawer-open #topDrawer { transform: translateY(0); pointer-events: auto; }
#topDrawer .drawer-bg { position: absolute; inset: 0; background: rgba(255,255,255,.86); backdrop-filter: saturate(180%) blur(8px); border-bottom: 1px solid #e6e6e6; }
:root[data-theme="dark"] #topDrawer .drawer-bg { background: rgba(16,16,16,.70); border-bottom-color: #272727; }
#topDrawer .drawer-inner { position: relative; height: 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 24px; padding: 12px 20px; padding-left: calc(20px + env(safe-area-inset-left)); padding-right: calc(20px + env(safe-area-inset-right)); font-size: 70%; line-height: 1.0; color: var(--fg); }
#topDrawer .col { overflow: auto; }
#drawerTOC { opacity: .7; display: grid; place-items: center; font-weight: 600; }
#drawerTOC::before { content: "TOC placeholder"; }
.drawer-controls { display: flex; gap: 12px; align-items: center; margin-bottom: 8px; }
.drawer-controls label { display: inline-flex; gap: 6px; align-items: center; cursor: pointer; user-select: none; }
.drawer-list { height: calc(100% - 28px); overflow: auto; padding-right: 6px; }
.drawer-item { display:flex; align-items:flex-start; gap:8px; margin:6px 0; }
.drawer-item .content { flex:1 1 auto; }
.drawer-item .del { flex: 0 0 auto; border:none; background:none; color:var(--muted); cursor:pointer; border-radius: 6px; width:24px; height:24px; display:grid; place-items:center; }
.drawer-item .del:hover { background: rgba(0,0,0,.06); }
:root[data-theme="dark"] .drawer-item .del:hover { background: rgba(255,255,255,.08); }
.drawer-item .del svg { width:16px; height:16px; }
</style><style>
/* === Drawer v2 adjustments === */
.topbar { background: transparent !important; border-bottom: none !important; position: fixed; overflow: visible; }
.topbar::before { content: ""; position: absolute; inset: 0; background: #fff; transition: transform .25s ease; z-index: 0; border-bottom: none; }
.topbar-inner { position: relative; z-index: 1; }
#topDrawer .drawer-bg { background: #fff !important; border-bottom: none !important; }
.progress-wrap { border-top: 1px solid #e6e6e6; border-bottom: none !important; transform: translateY(0); transition: transform .25s ease; }
:root[data-theme="dark"] .progress-wrap { border-top-color: #272727; }
:root[data-theme="dark"] .topbar { border-bottom: none !important; }
:root[data-theme="dark"] #topDrawer .drawer-bg { border-bottom: none !important; }
</style>
<style>
/* Overrides per 2025-09-19 (rev2):
   Solid backgrounds for top bar & drawer.
   Light mode: white. Dark mode: black. No transparency/blur.
*/
.topbar, .topbar::before, .topbar::after {
  background:#fff !important; backdrop-filter:none !important;
}
#topDrawer, #topDrawer .drawer-bg, #topDrawer .drawer-inner {
  background:#fff !important; backdrop-filter:none !important;
}
:root[data-theme="dark"] .topbar,
:root[data-theme="dark"] .topbar::before,
:root[data-theme="dark"] .topbar::after {
  background:#000 !important; backdrop-filter:none !important;
}
:root[data-theme="dark"] #topDrawer,
:root[data-theme="dark"] #topDrawer .drawer-bg,
:root[data-theme="dark"] #topDrawer .drawer-inner {
  background:#000 !important; backdrop-filter:none !important;
}

/* Keep subtle separators */
.topbar { border-bottom: 1px solid #e6e6e6 !important; }
:root[data-theme="dark"] .topbar { border-bottom: 1px solid #2a2a2a !important; }
#topDrawer .drawer-bg { border-bottom: 1px solid #e6e6e6 !important; }
:root[data-theme="dark"] #topDrawer .drawer-bg { border-bottom: 1px solid #2a2a2a !important; }
</style>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script><style>
/* --- App Shell: Login / Cloud / Reader screens --- */
.screen{max-width:1000px;margin:90px auto 80px;padding:0 20px}
.screen h1{font:600 28px/1.2 var(--reader-font);margin:0 0 16px}
.screen .muted{color:var(--muted);font-size:var(--ui)}
.screen .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:12px 0}
#screen-cloud .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:16px;margin-top:16px}
.card{border:1px solid rgba(0,0,0,.08);border-radius:12px;padding:12px}
:root[data-theme="dark"] .card{border-color:#2a2a2a}
.card .cover{
  width:100%;aspect-ratio:3/4;background:rgba(0,0,0,.06);
  border-radius:8px;overflow:hidden;display:grid;place-items:center
}
.card .meta{margin-top:10px}
.card .meta .title{font-weight:600;font-size:15px;line-height:1.3}
.card .meta .by{font-size:13px;color:var(--muted)}
.dropin{border:1.5px dashed rgba(0,0,0,.2);border-radius:14px;padding:20px;
  display:grid;place-items:center;font-size:14px;color:var(--muted);min-height:120px}
.dropin.drag{outline:2px solid var(--accent);outline-offset:4px}
#openBtn,.btn{border:1px solid rgba(0,0,0,.15);background:none;border-radius:10px;
  padding:8px 12px;font:600 14px/1 var(--reader-font);cursor:pointer}
:root[data-theme="dark"] #openBtn,:root[data-theme="dark"] .btn{border-color:#2a2a2a}
/* Hide reader chrome when not in reader mode */
.mode-login .topbar, .mode-login .progress-wrap, .mode-login #topDrawer,
.mode-cloud .topbar, .mode-cloud .progress-wrap, .mode-cloud #topDrawer{ display:none !important }
/* Let viewer area share the same vertical space baseline */

/* Normalize heading alignment and indentation from publisher CSS */
#viewer h1, #viewer h2, #viewer h3, #viewer h4, #viewer h5, #viewer h6 {
  /* Keep headings aligned with paragraph block edges */
  text-align: left !important;
  margin-left: 20px !important;
  margin-right: 20px !important;
  padding-left: 0 !important;
  text-indent: 0 !important;
}
/* override inline center styles on headings and subheads */
#viewer [style*="text-align:center"] { text-align: left !important; }
/* keep links readable */
#viewer a { text-underline-offset: 2px; }
</style><style id="patch-stage0-overlay">
.topbar-inner{position:relative;z-index:2}
    #topDrawer{pointer-events:none}
    body.drawer-open #topDrawer{pointer-events:auto}
</style><style id="patch-stage2-toolbar-clicks">
.topbar, .topbar-inner{pointer-events:auto}
    .topbar button, .topbar .icons, .topbar [role="button"]{pointer-events:auto}
</style>
<style id="toc-styles">
/* TOC in drawer — match reader content formatting */
#drawerTOC { 
  opacity: 1 !important; 
  display: block !important; 
  font-family: var(--reader-font); line-height: 1.6; 
  color: var(--fg);
}
#drawerTOC::before { content: none !important; }
#drawerTOC .toc-scroll { height: 100%; overflow: auto; padding-right: 6px; }
#drawerTOC .toc-item {
  margin: 0; /* align flush with title paddings */
  font-weight: 450;  /* match #viewer p weight */
  cursor: pointer;
  user-select: none;
}
#drawerTOC .toc-item:hover { text-decoration: underline; }
#drawerTOC .toc-item.toc-active { text-decoration: underline; }
#drawerTOC .lvl-2 { margin-left: 40px; opacity: .95; }
#drawerTOC .lvl-3 { margin-left: 60px; opacity: .9; }
#drawerTOC .lvl-4 { margin-left: 80px; opacity: .85; }
#drawerTOC .lvl-5 { margin-left: 100px; opacity: .8; }
#drawerTOC .lvl-6 { margin-left: 120px; opacity: .75; }
</style>


<style id="drawer-height-fixes">
/* Make both columns fill the drawer height */
#topDrawer .col { height: 100% !important; overflow: hidden; }
/* Records column: stack controls + list and let list fill remainder */
#drawerAnno { display: flex; flex-direction: column; height: 100%; }
#drawerAnno .drawer-controls { flex: 0 0 auto; }
#drawerList { flex: 1 1 auto; min-height: 0; height: auto !important; overflow: auto; }
/* TOC column should also fill */
#drawerTOC { height: 100% !important; }
</style>


<style id="drawer-font-scale">
#drawerTOC, #drawerList { font-size: 65% !important; }
</style>


<style id="remove-topbar-before">
/* Remove the sliding background below the top bar */
.topbar::before { content: none !important; display: none !important; background: transparent !important; }
.topbar.bg-shift::before { content: none !important; display: none !important; transform: none !important; }
</style>


<style id="drawer-spacing-1_5">
#drawerTOC, #drawerList { line-height: 1.5 !important; }
#drawerTOC .toc-item { line-height: 1.5 !important; }
</style>


<style id="toc-align-with-title">
#drawerTOC .toc-scroll {
  padding-left: calc(20px + env(safe-area-inset-left));
  padding-right: calc(20px + env(safe-area-inset-right));
}
#drawerTOC .toc-item { margin-left: 0 !important; margin-right: 0 !important; }
</style>


<style id="drawer-controls-svg-ticks">
/* Match drawer text size & spacing */
#drawerAnno .drawer-controls {
  font-size: 65% !important;
  line-height: 1.5 !important;
}
#drawerAnno .drawer-controls label {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  user-select: none;
  color: var(--fg);
}

/* Visually hide native checkbox but keep it accessible */
#drawerAnno .drawer-controls input[type="checkbox"]{
  position: absolute;
  opacity: 0;
  width: 1px;
  height: 1px;
  margin: 0;
  pointer-events: none;
}

/* SVG tickbox */
#drawerAnno .drawer-controls .tick {
  width: 1.15em;
  height: 1.15em;
  flex: 0 0 auto;
  display: inline-block;
}
#drawerAnno .drawer-controls .tick rect{
  fill: none;
  stroke: currentColor;
  stroke-width: 1.6;
  rx: 3;
}
#drawerAnno .drawer-controls .tick path{
  fill: none;
  stroke: currentColor;
  stroke-width: 2.4;
  stroke-linecap: round;
  stroke-linejoin: round;
  stroke-dasharray: 24;
  stroke-dashoffset: 24;
  transition: stroke-dashoffset .18s ease;
}

/* Checked state using :has() */
#drawerAnno .drawer-controls label:has(input:checked) .tick path{
  stroke-dashoffset: 0;
}
#drawerAnno .drawer-controls label:has(input:checked) .tick rect{
  fill: color-mix(in srgb, currentColor 8%, transparent);
}
/* Dark theme subtle fill */
:root[data-theme="dark"] #drawerAnno .drawer-controls label:has(input:checked) .tick rect{
  fill: color-mix(in srgb, currentColor 12%, transparent);
}
</style>


<style id="drawer-item-click">
.drawer-item { cursor: pointer; }
.drawer-item:hover { text-decoration: underline; }
.drawer-item .del { cursor: default; } /* delete button shouldn't look like a link */
</style>

</head>
<body>
<!-- Symbols (stroke-based for settings/sun/moon/refresh) -->
<svg aria-hidden="true" class="sr-only" height="0" style="position:absolute" width="0">
<!-- Settings -->
<symbol id="i-sliders" viewbox="0 0 24 24">
<g class="icon-stroke">
<line x1="4" x2="20" y1="6" y2="6"></line><circle cx="9" cy="6" r="2"></circle>
<line x1="4" x2="20" y1="12" y2="12"></line><circle cx="15" cy="12" r="2"></circle>
<line x1="4" x2="20" y1="18" y2="18"></line><circle cx="12" cy="18" r="2"></circle>
</g>
</symbol>
<!-- Sun -->
<symbol id="i-sun" viewbox="0 0 24 24">
<g class="icon-stroke">
<circle cx="12" cy="12" r="4"></circle>
<line x1="12" x2="12" y1="2" y2="5"></line>
<line x1="12" x2="12" y1="19" y2="22"></line>
<line x1="2" x2="5" y1="12" y2="12"></line>
<line x1="19" x2="22" y1="12" y2="12"></line>
<line x1="4.2" x2="6.4" y1="4.2" y2="6.4"></line>
<line x1="17.6" x2="19.8" y1="17.6" y2="19.8"></line>
<line x1="17.6" x2="19.8" y1="6.4" y2="4.2"></line>
<line x1="4.2" x2="6.4" y1="19.8" y2="17.6"></line>
</g>
</symbol>
<!-- Moon (stroke crescent) -->
<symbol id="i-moon" viewbox="0 0 24 24">
<path class="icon-stroke" d="M21 12.6A9 9 0 1 1 11.4 3a6.5 6.5 0 0 0 9.6 9.6z"></path>
</symbol>
<!-- Refresh (refined 'G' arrow — no horizontal stroke) -->
<symbol id="i-refresh" viewbox="0 0 24 24">
<g class="icon-stroke">
<path d="M21 12a9 9 0 1 1-3-6.7"></path>
<line x1="21" x2="21" y1="6" y2="12"></line>
<polyline points="19 8 21 6 23 8"></polyline>
</g>
</symbol>
<!-- Pencil -->
<symbol id="i-pencil" viewbox="0 0 24 24">
<g class="icon-stroke">
<path d="M3 21l3.75-.75L19 8l-3-3L3.75 17.25z"></path>
<path d="M14 5l3 3"></path>
</g>
</symbol>
</svg>
<div class="topbar" id="topbar">
<div class="topbar-inner">
<div class="title"><span id="bookTitle">Demo Book</span></div>
<div class="icons default" id="defaultIcons">
<button class="icon-btn" id="settingsBtn" title="Settings">
<svg viewbox="0 0 24 24"><use href="#i-sliders"></use></svg>
</button>
<!-- Bookmark icon -->
<button class="icon-btn bookmark" id="bookmarkBtn" title="Bookmark">
<svg viewbox="0 0 24 24"><path d="M6 3h12a1 1 0 0 1 1 1v17.2a.5.5 0 0 1-.8.4L12 17l-6.2 4.6a.5.5 0 0 1-.8-.4V4a1 1 0 0 1 1-1z"></path></svg>
</button>
</div>
<div class="icons annotate" id="annotateIcons">
<button class="icon-btn" data-hl="y" title="Highlight — Yellow"><span aria-hidden="true" class="annotate-color y"></span></button>
<button class="icon-btn" data-hl="g" title="Highlight — Green"><span aria-hidden="true" class="annotate-color g"></span></button>
<button class="icon-btn" data-hl="b" title="Highlight — Blue"><span aria-hidden="true" class="annotate-color b"></span></button>
<button class="icon-btn" data-hl="p" title="Highlight — Purple"><span aria-hidden="true" class="annotate-color p"></span></button>
<button class="icon-btn" data-hl="pk" title="Highlight — Pink"><span aria-hidden="true" class="annotate-color pk"></span></button>
<button class="icon-btn" id="underlineBtn" title="Dictionary (underline)">
<svg aria-hidden="true" class="dict-icon" viewbox="0 0 24 24">
<rect height="16" rx="3" ry="3" width="16" x="4" y="4"></rect>
<text x="12" y="12">Aa</text>
</svg>
</button>
</div>
<div aria-hidden="true" class="icons settings" id="settingsIcons">
<button class="icon-btn" id="fontCycle" title="Font">
<svg viewbox="0 0 24 24"><text class="uiText" x="12" y="12">Aa</text></svg>
</button>
<button class="icon-btn" id="fontPlus" title="A+">
<svg viewbox="0 0 24 24"><text class="uiText" x="12" y="12">A+</text></svg>
</button>
<button class="icon-btn" id="fontMinus" title="A-">
<svg viewbox="0 0 24 24"><text class="uiText" x="12" y="12">A-</text></svg>
</button>
<button class="icon-btn" id="themeToggle" title="Theme">
<svg height="22" id="themeIcon" preserveaspectratio="xMidYMid meet" viewbox="0 0 24 24" width="22">
<use href="#i-sun" id="themeIconUse" xlink:href="#i-sun"></use>
</svg>
</button>
<button class="icon-btn" id="refreshBtn" title="Reset">
<svg viewbox="0 0 24 24"><use href="#i-refresh"></use></svg>
</button>
</div>
</div>
</div>
<div class="progress-wrap" id="progressWrap"><div id="progressBar"><div class="progress-fill" id="progressFill"></div></div></div>
<div aria-hidden="true" id="topDrawer"><div class="drawer-bg"></div><div class="drawer-inner"><div class="col" id="drawerTOC"></div><div class="col" id="drawerAnno"><div class="drawer-controls"><label><input checked="" id="tickHl" type="checkbox"/> Highlight</label><label><input checked="" id="tickGloss" type="checkbox"/> Glossary</label><label><input checked="" id="tickNote" type="checkbox"/> Note</label></div><div class="drawer-list" id="drawerList"></div></div></div></div>
<section class="screen" hidden="" id="screen-login">
<h1>Welcome back</h1>
<p class="muted">Sign in to sync your library, notes, and progress — or continue as guest.</p>
<div class="row">
<form class="row" id="loginForm" onsubmit="return false;">
<input id="loginEmail" placeholder="you@example.com" style="padding:8px 10px;border:1px solid rgba(0,0,0,.2);border-radius:10px;min-width:260px" type="email"/>
<button class="btn" id="loginSend" title="(stub)" type="button">Send magic link</button>
</form>
<button class="btn" id="guestBtn" type="button">Continue as guest</button>
</div>
</section>
<section class="screen" hidden="" id="screen-cloud">
<h1>Your Library</h1>
<div class="row">
<input id="cloudSearch" placeholder="Search" style="flex:1;min-width:200px;padding:8px 10px;border:1px solid rgba(0,0,0,.2);border-radius:10px"/>
<label class="btn" for="fileInput" id="openBtn">Open…</label>
<input accept=".epub,.pdf" id="fileInput" multiple="" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;" type="file"/>
</div>
<div class="dropin" id="dropZone">Drop EPUB/PDF files here</div>
<div class="grid" id="libraryGrid"></div>
</section>
<div class="viewer-wrap"><article id="viewer"></article></div>
<script>
// Demo content (more book‑like, varied paragraphs)
const v=document.getElementById('viewer');
(function seedBookLike(){
  const sentences=[
    "The train slid out of the tunnel and the city uncoiled beneath a sky the color of pewter.",
    "I carried the letter in my pocket for three days before I dared to read it.",
    "He spoke softly, as if the wrong word might wake the house.",
    "Outside, the wind braided itself through the trees and came back smelling of rain.",
    "We had agreed not to look back, but the road behind us kept whispering our names.",
    "There are clocks that only tell a story when they break.",
    "She laughed then, sudden and bright, and the room remembered how to breathe.",
    "The map was older than any of us, and less trustworthy.",
    "At the harbor, the gulls argued like old men playing cards.",
    "I was not brave, only tired of being afraid.",
    "Night fell the way it always does—quietly at first, then all at once.",
    "He wore his grief the way soldiers wear medals: heavy and close to the heart.",
    "In the morning the rain had washed the world a shade cleaner than the day before.",
    "‘Listen,’ she said, and I did, because the way she said it made silence important.",
    "The elevator sighed as if relieved to be useful.",
    "Some promises keep themselves; others have to be fed and walked like dogs.",
    "I found the key where I’d left it: in the last place I wanted to look.",
    "The sea kept its own counsel, which is to say it lied beautifully.",
    "There is a particular loneliness reserved for waiting rooms and afterthoughts.",
    "He folded the paper into a ship and set it sailing across the empty desk."
  ];
  function lcg(seed){ let s=seed>>>0; return ()=> (s=(s*1664525+1013904223)>>>0)/4294967296; }
  const rnd = lcg(12345);
  const paraCount = 60;
  for(let i=0;i<paraCount;i++){
    const len = 2 + Math.floor(rnd()*7); // 2..8 sentences
    let out=[];
    for(let j=0;j<len;j++){
      const s = sentences[Math.floor(rnd()*sentences.length)];
      out.push(s);
    }
    const p=document.createElement('p');
    p.textContent = out.join(' ');
    v.appendChild(p);
    // occasional short scene break
    if(i>0 && i%12===0){
      const br=document.createElement('p'); br.textContent=""; v.appendChild(br);
    }
  }
})();

// State

const state={theme:'auto',fontFamily:'sans',fontSizePx:27,currentBook:{id:'demo', title:'Demo', bookmarks:[], lastPercent:0}, settingsOpen:false};
const clamp=(n,a,b)=>Math.max(a,Math.min(b,n)); const BOOKMARK_EPS=0.01;

// Layout
function adjustBodyOffset(){ const top=document.getElementById('topbar')?.offsetHeight||0; document.getElementById('progressWrap').style.top = top + 'px'; document.body.style.paddingTop = (top + 10) + 'px'; }
window.addEventListener('resize',adjustBodyOffset); adjustBodyOffset();

// Progress
function getScrollPercent(){ const sc = document.documentElement.scrollTop || document.body.scrollTop; const max = (document.documentElement.scrollHeight - document.documentElement.clientHeight) || 1; return clamp(sc/max,0,1); }
function onScroll(){ const p=getScrollPercent(); state.currentBook.lastPercent=p; document.getElementById('progressFill').style.width=(p*100).toFixed(2)+'%'; updateBookmarkFilled(); }
window.addEventListener('scroll',onScroll,{passive:true}); onScroll();

// Bookmarks
function isNear(a,b,eps=BOOKMARK_EPS){ return Math.abs(a-b)<=eps; }
function indexOfNearbyBookmark(p){ const bm=state.currentBook.bookmarks; for(let i=0;i<bm.length;i++){ if(isNear(bm[i].p,p)) return i; } return -1; }
function isNearBookmark(p){ return indexOfNearbyBookmark(p)!==-1; }
function renderPins(){ const bar=document.getElementById('progressBar'); bar.querySelectorAll('.pin').forEach(n=>n.remove()); for(const b of state.currentBook.bookmarks){ const pin=document.createElement('div'); pin.className='pin'; pin.style.left=(b.p*100)+'%'; pin.addEventListener('click',e=>{e.stopPropagation(); jumpToPercent(b.p);}); bar.appendChild(pin);} }
function updateBookmarkFilled(){ const p=state.currentBook.lastPercent; document.getElementById('bookmarkBtn').classList.toggle('active', isNearBookmark(p)); }
function addBookmarkAtCurrent(){ const p=state.currentBook.lastPercent; if(isNearBookmark(p)) return; state.currentBook.bookmarks.push({p}); state.currentBook.bookmarks.sort((a,b)=>a.p-b.p); renderPins(); updateBookmarkFilled(); }
function removeCurrentNearbyBookmark(){ const p=state.currentBook.lastPercent; const i=indexOfNearbyBookmark(p); if(i!==-1){ state.currentBook.bookmarks.splice(i,1); renderPins(); updateBookmarkFilled(); } }
function toggleBookmarkAtCurrent(){ const p=state.currentBook.lastPercent; if(isNearBookmark(p)) removeCurrentNearbyBookmark(); else addBookmarkAtCurrent(); }
function jumpToPercent(p){ const max=(document.documentElement.scrollHeight-document.documentElement.clientHeight); const y=clamp(p,0,1)*max; window.scrollTo({top:y}); requestAnimationFrame(onScroll); }
renderPins(); updateBookmarkFilled();

// Settings toggle & theme swap (unchanged logic)
function toggleSettings(on){ if(on===undefined) on=!state.settingsOpen; state.settingsOpen=!!on; document.getElementById('topbar').classList.toggle('settings-mode', state.settingsOpen); adjustBodyOffset(); bumpSettingsIdle(); }
function bumpSettingsIdle(){ clearTimeout(state._idle); if(state.settingsOpen){ state._idle=setTimeout(()=>{ state.settingsOpen=false; document.getElementById('topbar').classList.remove('settings-mode'); adjustBodyOffset(); },3000);} }
function setTheme(mode){
  state.theme=mode;
  const root=document.documentElement;
  const prefersDark=matchMedia && matchMedia('(prefers-color-scheme: dark)').matches;
  const isDark = (mode==='dark') || (mode==='auto' && prefersDark);
  if(mode==='dark'){ root.setAttribute('data-theme','dark'); }
  else if(mode==='light'){ root.setAttribute('data-theme','light'); }
  else { root.removeAttribute('data-theme'); }
  const use=document.getElementById('themeIconUse');
  if(use){ const id=isDark ? '#i-sun' : '#i-moon'; use.setAttribute('href', id); use.setAttribute('xlink:href', id); }
}

document.addEventListener('click',(e)=>{
  if(e.target.closest('#bookmarkBtn')) toggleBookmarkAtCurrent();
  if(e.target.closest('#settingsBtn')) toggleSettings(true);
  if(e.target.closest('#fontPlus')){ state.fontSizePx++; document.documentElement.style.setProperty('--base', state.fontSizePx+'px'); bumpSettingsIdle(); }
  if(e.target.closest('#fontMinus')){ state.fontSizePx--; document.documentElement.style.setProperty('--base', state.fontSizePx+'px'); bumpSettingsIdle(); }
  if(e.target.closest('#fontCycle')){ const order=['sans','georgia','serif']; const i=order.indexOf(state.fontFamily); state.fontFamily=order[(i+1)%order.length]; let f='serif'; if(state.fontFamily==='sans') f='ui-sans-serif,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"'; if(state.fontFamily==='georgia') f='Georgia, serif'; document.documentElement.style.setProperty('--reader-font',f); bumpSettingsIdle(); }
  if(e.target.closest('#themeToggle')){ const next=state.theme==='auto'?'dark':(state.theme==='dark'?'light':'auto'); setTheme(next); bumpSettingsIdle(); }
  if(e.target.closest('#refreshBtn')){ state.fontFamily='sans'; document.documentElement.style.setProperty('--reader-font','ui-sans-serif,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"'); state.fontSizePx=27; document.documentElement.style.setProperty('--base','27px'); setTheme('auto'); bumpSettingsIdle(); }
});
setTheme('auto');
</script>
<script>
(function(){
  'use strict';

  // Grouping for cross-paragraph annotations
  let nextAnnotId = 1;
  function newAnnotId(){ return 'a' + (nextAnnotId++); }
  function getGroupId(el){ return el && el.dataset ? el.dataset.annotId : null; }
  function setGroupId(el, id){ if(el && el.dataset) el.dataset.annotId = id; }
  function byGroup(selector, id){ return Array.from(viewer.querySelectorAll(selector + '[data-annot-id="'+id+'"]')); }
  function setDomSelection(range){
    try{
      __squelchSel = true;
      const sel = window.getSelection();
      if(sel){ sel.removeAllRanges(); sel.addRange(range); }
    }finally{
      // allow selectionchange to fire once we've applied ours
      setTimeout(()=>{ __squelchSel = false; }, 0);
    }
  }
// --- Elements ---
  const viewer = document.getElementById('viewer');
  const topbar = document.getElementById('topbar');
  const annotateIcons = document.getElementById('annotateIcons');

  // Bail if UI is missing
  if(!viewer || !topbar || !annotateIcons) return;

  // --- State ---
  let selRange = null;       // live selection (trimmed)
  let editTarget = null;     // existing <span.hl|.gloss> when editing
  let editGroupId = null;    // group id of current edit (spans across paragraphs)


  // --- Utilities ---
  const isSpace = ch => /\s/.test(ch);

  function inViewer(node){
    return node && (node === viewer || viewer.contains(node));
  }

  function trimRangeSpaces(range){
    const r = range.cloneRange();
    // Start
    let sc=r.startContainer, so=r.startOffset;
    while(sc.nodeType !== Node.TEXT_NODE){
      sc = sc.childNodes[so] || sc.nextSibling;
      if(!sc) break; so = 0;
    }
    if(!sc) return null;
    while(so < sc.nodeValue.length && isSpace(sc.nodeValue[so])) so++;

    // End
    let ec=r.endContainer, eo=r.endOffset;
    while(ec.nodeType !== Node.TEXT_NODE){
      ec = ec.childNodes[eo-1] || ec.previousSibling;
      if(!ec) break; eo = ec.nodeValue.length;
    }
    if(!ec) return null;
    while(eo > 0 && isSpace(ec.nodeValue[eo-1])) eo--;

    if(sc===ec && eo<=so) return null;
    const out=document.createRange(); out.setStart(sc,so); out.setEnd(ec,eo); return out;
  }

  function rangesOverlap(a,b){
    try{
      return a.compareBoundaryPoints(Range.START_TO_END,b)>0 && a.compareBoundaryPoints(Range.END_TO_START,b)<0;
    }catch(_){ return false; }
  }

  function unwrap(el){
    const p=el.parentNode; if(!p) return;
    while(el.firstChild) p.insertBefore(el.firstChild, el);
    p.removeChild(el);
  }

  function rangeFromElement(el){
    const r=document.createRange(); r.selectNodeContents(el); return r;
  }

  function getMarks(selector){
    return Array.from(viewer.querySelectorAll(selector));
  }

  // Merge adjacent spans with identical className
  function mergeAdjacent(selector){
    const list = Array.from(viewer.querySelectorAll(selector));
    list.forEach(s=>{
      let next=s.nextSibling;
      // absorb whitespace between same-class spans
      while(next && next.nodeType===3 && /^\s+$/.test(next.nodeValue)){ s.appendChild(next); next=s.nextSibling; }
      while(next && next.nodeType===1 && next.matches(selector) && next.className===s.className){
        while(next.firstChild) s.appendChild(next.firstChild);
        const rm=next; next=next.nextSibling; rm.remove();
        while(next && next.nodeType===3 && /^\s+$/.test(next.nodeValue)){ s.appendChild(next); next=s.nextSibling; }
      }
    });
  }

  // Wrap text nodes fully or partially covered by range
  function wrapRange(range, className, annotId){
    const targets=[];
    const walker=document.createTreeWalker(viewer, NodeFilter.SHOW_TEXT, {
      acceptNode(node){
        if(!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
        const r2=document.createRange(); r2.selectNodeContents(node);
        const a = range.compareBoundaryPoints(Range.START_TO_END, r2) > 0;
        const b = range.compareBoundaryPoints(Range.END_TO_START, r2) < 0;
        return (a && b) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
      }
    });
    let n; while((n=walker.nextNode())) targets.push(n);
    targets.forEach(node=>{
      let s=0, e=node.nodeValue.length;
      if(node===range.startContainer) s=range.startOffset;
      if(node===range.endContainer)   e=range.endOffset;
      if(s>=e) return;
      if(e<node.nodeValue.length) node.splitText(e);
      let mid=node; if(s>0) mid=node.splitText(s);
      const span=document.createElement('span'); span.className=className; if(annotId) setGroupId(span, annotId);
      mid.parentNode.insertBefore(span, mid); span.appendChild(mid);
    });
  }

  // Remove overlapping highlights completely in a range (simplifies logic)
  function removeOverlappingHighlights(range){
    getMarks('.hl').forEach(el=>{
      const r2=rangeFromElement(el);
      if(rangesOverlap(range, r2)) unwrap(el);
    });
  }

  function showAnnotate(){
    topbar.classList.add('annotate-mode');
  }
  function hideAnnotate(){
    topbar.classList.remove('annotate-mode');
    selRange = null;
    editTarget = null;
    // also clear real selection so accidental re-open doesn't occur
    try{ const sel=window.getSelection(); sel && sel.removeAllRanges(); }catch(_){}
  }

  // --- Selection tracking ---
  function updateSelection(){
        const sel = window.getSelection();
    if(!sel || sel.rangeCount===0){
      selRange = null;
      topbar.classList.remove('annotate-mode');
      return;
    }
    const r = sel.getRangeAt(0);
    if(r.collapsed || !inViewer(r.commonAncestorContainer)){
      selRange = null;
      topbar.classList.remove('annotate-mode');
      return;
    }
    selRange = trimRangeSpaces(r);
    editTarget = null; // new selection wins
    if(selRange) showAnnotate(); else topbar.classList.remove('annotate-mode');
  }

  document.addEventListener('selectionchange', updateSelection);
  viewer.addEventListener('mouseup', updateSelection, {passive:true});
  viewer.addEventListener('keyup', (e)=>{
    if(e.key.startsWith('Arrow') || e.key==='Shift') updateSelection();
  });

  // Clicking an existing highlight/underline enters EDIT mode
  viewer.addEventListener('click', (e)=>{
    const mark = e.target.closest('span.hl, span.gloss');
    if(!mark) return;
    if(e.target.closest('a[href]')) return;
    e.preventDefault();
    e.stopPropagation();
    const r = rangeFromElement(mark);
    // (patched) do not set DOM selection; we keep it internal only to avoid blue selection flash
    selRange = r.cloneRange();
    editTarget = mark;
    editGroupId = getGroupId(mark);
    showAnnotate();
  }, true);

  // Close annotate when clicking outside viewer/topbar
  // (patched) removed pointerdown selection to prevent native selection flash on click
document.addEventListener('click', (e)=>{
    if(e.target.closest('#topbar') || e.target.closest('#viewer')) return;
    hideAnnotate();
  });

  // --- Actions ---
  function removeHlClasses(el){
    // remove only colour-specific classes; keep the base 'hl'
    el.className = el.className.replace(/\bhl-(y|g|b|pk|p)\b/g, '').trim();
  }

  function ensureHl(el){
    if(!/\bhl\b/.test(el.className)) el.classList.add('hl');
  }

  function applyColorToTarget(target, color){
    // toggle off if same color already applied
    if(target.classList.contains('hl-'+color)){
      target.classList.remove('hl','hl-'+color);
      if(!target.classList.contains('gloss')) unwrap(target);
      return;
    }
    removeHlClasses(target);
    ensureHl(target);
    target.classList.add('hl-'+color);
  }

  function applyUnderlineToTarget(target){
    if(target.classList.contains('gloss')){
      target.classList.remove('gloss');
      if(!/\bhl-(y|g|b|pk|p)\b/.test(target.className)) unwrap(target);
      return;
    }
    target.classList.add('gloss');
  }

  function applyHighlight(color){
    if(editTarget){
      const gid = editGroupId || getGroupId(editTarget);
      if(gid){
        const els = byGroup('span.hl', gid);
        if(els.length){ els.forEach(el=>applyColorToTarget(el, color)); }
        else { byGroup('span.gloss', gid).forEach(el=>applyColorToTarget(el, color)); }
      } else {
        applyColorToTarget(editTarget, color);
      }
mergeAdjacent('span.hl');
      hideAnnotate();
      return;
    }
    if(!selRange) return;
    const r = selRange.cloneRange();
    removeOverlappingHighlights(r);
    const gid = newAnnotId();
    wrapRange(r, 'hl hl-'+color, gid);
    mergeAdjacent('span.hl');
    hideAnnotate();
  }

  function applyUnderline(){
    if(editTarget){
      const gid = editGroupId || getGroupId(editTarget);
      if(gid){
        const els = byGroup('span.hl', gid);
        if(els.length){ els.forEach(applyUnderlineToTarget); }
        else { byGroup('span.gloss', gid).forEach(applyUnderlineToTarget); }
      } else {
        applyUnderlineToTarget(editTarget);
      }
      mergeAdjacent('span.hl'); // in case unwrap happened
      hideAnnotate();
      return;
    }
    if(!selRange) return;
    // If selection sits inside an existing highlight, add gloss to that highlight instead of nesting
    const containingHl = (function(){
      const node = selRange.commonAncestorContainer.nodeType===1 ? selRange.commonAncestorContainer : selRange.commonAncestorContainer.parentElement;
      return node && node.closest && node.closest('span.hl');
    })();
    if(containingHl){
      const gid = getGroupId(containingHl);
      if(gid){ byGroup('span.hl', gid).forEach(applyUnderlineToTarget); }
      else { applyUnderlineToTarget(containingHl); }
      mergeAdjacent('span.hl');
      hideAnnotate();
      return;
    }
    // Else wrap fresh underline as a grouped gloss
    const gid = newAnnotId();
    wrapRange(selRange, 'gloss', gid);
    hideAnnotate();
  }

  // Button wiring: clicking a chip or underline closes the bar after applying
  annotateIcons.addEventListener('click', (e)=>{
    const btn = e.target.closest('button.icon-btn');
    if(!btn) return;
    const color = btn.getAttribute('data-hl');
    if(color){ applyHighlight(color); return; }
    if(btn.id === 'underlineBtn'){ applyUnderline(); return; }
  });

})(); 
</script>
<script>
(function drawerBase(){
  const topbarInner = document.querySelector('.topbar-inner');
  const drawer = document.getElementById('topDrawer');
  const progressWrap = document.getElementById('progressWrap');
  const viewer = document.getElementById('viewer');
  const drawerList = document.getElementById('drawerList');
  const tickHl = document.getElementById('tickHl');
  const tickGloss = document.getElementById('tickGloss');
  const tickNote = document.getElementById('tickNote');
  if(!topbarInner || !drawer || !progressWrap || !viewer) return;

  function setDrawerOpen(on){
    document.body.classList.toggle('drawer-open', !!on);
    drawer.setAttribute('aria-hidden', on ? 'false' : 'true');

    if(on) rebuildList();
  }
  function isDrawerOpen(){ return document.body.classList.contains('drawer-open'); }
  topbarInner.addEventListener('click', (e)=>{
    const inTitle = e.target.closest('#bookTitle');
    const inDefaultIcons = e.target.closest('#defaultIcons');
    const inAnyBtn = e.target.closest('.icon-btn');
    if(inTitle || inDefaultIcons || inAnyBtn) return;
    setDrawerOpen(!isDrawerOpen());
  });
  document.addEventListener('click', (e)=>{
    if(!isDrawerOpen()) return;
    if(e.target.closest('.topbar') || e.target.closest('#topDrawer')) return;
    setDrawerOpen(false);
  });
  drawer.addEventListener('click', (e)=>{ if(e.target === drawer || e.target.classList.contains('drawer-bg')) setDrawerOpen(false); });
  const settingsBtn = document.getElementById('settingsBtn'); if(settingsBtn){ settingsBtn.addEventListener('click', ()=> setDrawerOpen(false)); }

  function rebuildList(){
    drawerList.innerHTML='';
    const showHl = tickHl?.checked !== false;
    const showGloss = tickGloss?.checked !== false;
    const showNote = tickNote?.checked !== false;
    const viewerEl = document.getElementById('viewer');
    const byId = new Map();
    function pushItem(kind, el){
      const id = el.dataset?.annotId || Math.random().toString(36).slice(2);
      const key = id + '|' + kind;
      if(!byId.has(key)) byId.set(key, {kind, els:[]});
      byId.get(key).els.push(el);
    }
    if(showHl){ viewerEl.querySelectorAll('span.hl').forEach(el=> pushItem('hl',el)); }
    if(showGloss){ viewerEl.querySelectorAll('span.gloss').forEach(el=> pushItem('gloss',el)); }
    if(showNote){ viewerEl.querySelectorAll('.note-block').forEach(el=> pushItem('note',el)); }
    for(const [k,g] of byId){
      const li = document.createElement('div'); li.className='drawer-item';
      // Jump into the book when a record is clicked
      li.addEventListener('click', (ev)=>{
        if(ev.defaultPrevented) return;
        // avoid clicks on the delete button bubbling as a jump
        if(ev.target.closest && ev.target.closest('.del')) return;
        const first = (g.els && g.els[0]) || null;
        if(first){
          try{ first.scrollIntoView({behavior:'smooth', block:'center'}); }catch{}
          // Optionally close drawer to reveal content
          try{ document.body.classList.remove('drawer-open'); }catch{}
        }
      });
      const content = document.createElement('div'); content.className='content';
      if(g.kind==='note'){ const sample=g.els[0].cloneNode(true); sample.classList.remove('is-editing'); sample.removeAttribute('contenteditable'); sample.style.margin='2px 0'; content.appendChild(sample); }
      else { const frag=document.createElement('span'); g.els.forEach((el,i)=>{ frag.appendChild(el.cloneNode(true)); if(i<g.els.length-1) frag.appendChild(document.createTextNode(' ')); }); content.appendChild(frag); }
      const del = document.createElement('button'); del.className='del'; del.innerHTML='<svg viewBox="0 0 24 24"><g class="icon-stroke"><line x1="6" y1="6" x2="18" y2="18"/><line x1="18" y1="6" x2="6" y2="18"/></g></svg>'; del.title='Remove';
      del.addEventListener('click', (ev)=>{ ev.stopPropagation(); if(g.kind==='note'){ g.els.forEach(el=>el.remove()); } else if(g.kind==='hl'){ g.els.forEach(el=>{ el.classList.remove('hl','hl-y','hl-g','hl-b','hl-pk','hl-p'); if(!el.classList.length){ const p=el.parentNode; while(el.firstChild) p.insertBefore(el.firstChild, el); el.remove(); } }); } else { g.els.forEach(el=>{ el.classList.remove('gloss'); if(!/hl/.test(el.className)){ const p=el.parentNode; while(el.firstChild) p.insertBefore(el.firstChild, el); el.remove(); } }); } rebuildList(); });
      li.appendChild(content); li.appendChild(del); drawerList.appendChild(li);
    }
  }
  tickHl?.addEventListener('change', rebuildList);
  tickGloss?.addEventListener('change', rebuildList);
  tickNote?.addEventListener('change', rebuildList);
})(); 
</script>
<script>
(function drawerAdjustments(){
  const topbar = document.getElementById('topbar');
  const progressWrap = document.getElementById('progressWrap');
  const drawer = document.getElementById('topDrawer');
  if(!topbar || !progressWrap || !drawer) return;
  function layoutDrawerTop(){
    const topH = topbar.offsetHeight || 0;
    const progH = progressWrap.offsetHeight || 10;
    drawer.style.top = topH + 'px';
  }
  layoutDrawerTop();
  window.addEventListener('resize', layoutDrawerTop);
  function applyOpenState(){
    const on = document.body.classList.contains('drawer-open');
    topbar.classList.toggle('bg-shift', on);
    progressWrap.style.transform = on ? 'translateY(150px)' : 'translateY(0)';
  }
  const style = document.createElement('style');
  style.textContent = '.topbar.bg-shift::before{ transform: translateY(150px); }';
  document.head.appendChild(style);
  const obs = new MutationObserver(applyOpenState);
  obs.observe(document.body, { attributes:true, attributeFilter:['class'] });
  applyOpenState();
})();
</script>

<script>
// --- App shell: tiny hash router + Library + EPUB loader (keeps your existing reader untouched)
(function(){
  const $ = (sel, el=document)=> el.querySelector(sel);
  const $$ = (sel, el=document)=> Array.from(el.querySelectorAll(sel));
  const screens = {
    login: $('#screen-login'),
    cloud: $('#screen-cloud'),
    reader: $('.viewer-wrap')
  };
  const html = document.documentElement;

  // Global-ish app state
  const app = {
    user: { mode:'guest', email:null },
    library: [],                 // [{id,title,author,type,source,href,cover}]
    byId: new Map(),             // id -> item
    currentId: null
  };

  // Toggle screen + chrome
  function show(mode){ // 'login' | 'cloud' | 'reader'
    for(const [k,el] of Object.entries(screens)){ if(!el) continue; el.hidden = (k!==mode); }
    html.classList.remove('mode-login','mode-cloud','mode-reader');
    html.classList.add('mode-'+mode);
  }

  // Simple router
  function route(){
    const h = location.hash || '#/login';
    const [_, name, rest] = h.split('/');  // #/read/:id
    if(name==='login'){ show('login'); }
    else if(name==='cloud'){ show('cloud'); }
    else if(name==='read'){
      const id = decodeURIComponent(rest||'');
      if(id && app.byId.has(id)){ app.currentId = id; openItem(app.byId.get(id)); }
      show('reader');
      try{ window.buildTOC && window.buildTOC(); }catch{}
    } else {
      location.replace('#/login');
      return;
    }
    // When not reading, ensure reader area starts clean
    if(name!=='read'){
      const v = document.getElementById('viewer'); if(v) v.innerHTML='';
      const title = document.getElementById('bookTitle'); if(title) title.textContent = 'Library';
      window.scrollTo({top:0, behavior:'instant'});
    }
  }
  window.addEventListener('hashchange', route);

  // Login actions (magic link)
  $('#guestBtn')?.addEventListener('click', ()=>{
    app.user = { mode:'guest', email:null };
    location.hash = '#/cloud';
  });

  $('#loginSend')?.addEventListener('click', async ()=>{
    const email = $('#loginEmail')?.value?.trim();
    if(!email) return alert('Enter your email');

    const btn = $('#loginSend'); if (btn) btn.disabled = true;
    let link = null;
    try {
      const r = await fetch('/api/auth/request-link', {
        method:'POST',
        headers:{'content-type':'application/json'},
        body: JSON.stringify({ email })
      });
      const raw = await r.text();
      try { link = JSON.parse(raw).link } catch {}
      if (!link) {
        const m = raw.match(/https?:\/\/[^"']+\/api\/auth\/exchange\?t=[^"'\s<>]+/i);
        link = m && m[0];
      }
      if (!link) throw new Error('Server did not return a link');

      // Exchange (set cookie)
      await fetch(link, { redirect:'manual', credentials:'include' });

      // Verify session
      const meRes = await fetch('/api/me', { credentials:'include', cache:'no-store' });
      if (!meRes.ok) throw new Error('Sign-in failed');
      const me = await meRes.json();

      app.user = { mode:'cloud', email: me.user?.email || email };
      location.hash = '#/cloud';
    } catch(e){
      console.error(e);
      alert('Could not sign in. If this keeps happening, click the "exchange" link if shown, then refresh.');
    } finally {
      if (btn) btn.disabled = false;
    }
  });

  // Library rendering
  function card(item){
    const div = document.createElement('div');
    const displayTitle = [item.title, item.author].filter(Boolean).join(' - ');
    div.className = 'card';
    div.innerHTML = `
      <div class="cover">${ item.cover ? `<img alt="" src="${item.cover}" style="width:100%;height:100%;object-fit:cover">` : '<span class="muted">no cover</span>' }</div>
      <div class="meta">
        <div class="title">${ displayTitle || item.id }</div>
        <div class="row">
          <button class="btn open">Open</button>
          ${ item.source==='dropin' ? '<button class="btn remove">Remove</button>' : ''}
        </div>
      </div>`;
    div.querySelector('.open').addEventListener('click', async ()=>{ try{ await openItem(item); }catch(e){ console.error(e); alert('Failed to open: '+(e?.message||e)); } });
    if(item.source==='dropin'){
      div.querySelector('.remove').addEventListener('click', ()=>{
        app.byId.delete(item.id);
        app.library = app.library.filter(x=>x.id!==item.id);
        renderLibrary();
      });
    }
    return div;
  }

  function renderLibrary(){
    const q = ($('#cloudSearch')?.value || '').toLowerCase();
    const grid = $('#libraryGrid'); if(!grid) return;
    grid.innerHTML='';
    const items = !q ? app.library : app.library.filter(x => (x.title||'').toLowerCase().includes(q) || (x.author||'').toLowerCase().includes(q));
    items.forEach(it => grid.appendChild(card(it)));
  }
  $('#cloudSearch')?.addEventListener('input', renderLibrary);

  // Load manifest (bundled content)
  async function tryLoadManifest(){
    // Try cloud library first
    try {
      const me = await fetch('/api/me', { credentials:'include', cache:'no-store' });
      if (me.ok) {
        const r = await fetch('/api/books', { credentials:'include', cache:'no-store' });
        if (r.ok) {
          const list = await r.json();
          const rows = Array.isArray(list) ? list : (list.books || []);
          if (Array.isArray(rows)) {
            for (const b of rows) {
              const id = b.id;
              const item = {
                id,
                type: (b.type === 'pdf' ? 'pdf' : 'epub'),
                source: 'cloud',
                title: b.title || '',
                author: b.author || '',
                cover: b.cover || '',
                href: `/api/books/${encodeURIComponent(id)}/file`
              };
              app.library.push(item); app.byId.set(item.id, item);
            }
            renderLibrary();
            return;
          }
        }
      }
    } catch(_) {}

    // Fallback: bundled samples (optional)
    try{
      const res = await fetch('contents/manifest.json', {cache:'no-store'});
      if(!res.ok) return;
      const data = await res.json();
      if(Array.isArray(data)){
        for(const it of data){
          const id = it.id || it.href || (it.title||'item-'+Math.random().toString(36).slice(2));
          const item = {...it, id, source: it.source || 'bundled'};
          app.library.push(item); app.byId.set(item.id, item);
        }
      }

      // Enrich EPUB items with metadata
      try{
        const tasks = app.library
          .filter(x => x.source==='bundled' && x.type==='epub' && x.href)
          .map(async x => {
            try{
              const b = await (await fetch(x.href)).blob();
              const meta = await extractEpubMetaFromBlob(b);
              x.title = meta.title || x.title || '';
              x.author = meta.author || x.author || '';
              if(meta.cover) x.cover = meta.cover;
            }catch{}
          });
        await Promise.allSettled(tasks);
      }catch{}
      renderLibrary();
    }catch{}
  }
// Drop-in / Open
  const input = $('#fileInput');
  // Label#openBtn with for=fileInput handles opening natively (Safari-safe).
  input?.addEventListener('change', e=> handleFiles(e.target.files));

  const drop = $('#dropZone');
  if(drop){
    ['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.add('drag'); }));
    ;['dragleave','drop'].forEach(ev => drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.remove('drag'); }));
    drop.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
  }

  async function handleFiles(fileList){
    const files = Array.from(fileList || []);
    for(const f of files){
      const id = f.name + '|' + f.size;
      const type = (/\.pdf$/i.test(f.name) ? 'pdf' : 'epub');
      const item = { id, type, source:'dropin', file: f, title:'', author:'' };
      if(type==='epub'){
        try{
          const meta = await extractEpubMetaFromBlob(f);
          item.title = meta.title || item.title;
          item.author = meta.author || item.author;
          if(meta.cover) item.cover = meta.cover;
        }catch(e){ /* ignore meta errors */ }
      }
      app.library.unshift(item); app.byId.set(item.id, item);
    }
    renderLibrary();
  }

  async function openItem(item){
    try{
    if(item.type==='epub'){
      const blob = item.file ? item.file : await (await fetch(item.href, { credentials:'include', cache:'no-store' })).blob();
      await loadEPUBFromBlob(blob, item);
      location.hash = '#/read/' + encodeURIComponent(item.id);
    } else if(item.type==='pdf'){
      const v = document.getElementById('viewer'); v.innerHTML = '<p class="muted">PDF viewer not integrated yet. (stub)</p>';
      document.getElementById('bookTitle').textContent = [item.title || 'PDF', item.author].filter(Boolean).join(' - ');
      location.hash = '#/read/' + encodeURIComponent(item.id);
      window.scrollTo({top:0, behavior:'instant'});
    } else {
      alert('Unsupported file type');
    }
    } catch(err){
      console.error(err);
      throw err;
    }
  }

  // --- Minimal EPUB loader using JSZip + DOMParser (no external XML lib)
  
  async function loadEPUBFromBlob(blob, item){
  // Reusable: parse minimal EPUB metadata (title, author, cover) from a Blob
  async function extractEpubMetaFromBlob(blob){
    const zip = await JSZip.loadAsync(blob);
    async function readText(path){
      let f = zip.file(path) || zip.file(path && path.replace(/^\//,''));
      if(!f && path){ try{ f = zip.file(decodeURIComponent(path)); }catch{} }
      if(!f && path){ try{ f = zip.file(decodeURIComponent(path.replace(/^\//,''))); }catch{} }
      if(!f) return null;
      return await f.async('string');
    }
    function parseXml(str){ return new DOMParser().parseFromString(str, 'application/xml'); }
    function joinPath(base, rel){
      if(!rel) return base;
      if(/^https?:|^data:|^blob:/.test(rel)) return rel;
      if(rel.startsWith('/')) return rel.slice(1);
      const stack = base.split('/'); stack.pop();
      for(const seg of rel.split('/')){ if(!seg||seg==='.') continue; if(seg==='..') stack.pop(); else stack.push(seg); }
      return stack.join('/');
    }

    const containerDoc = parseXml(await readText('META-INF/container.xml'));
    const rootfileEl = containerDoc && containerDoc.querySelector('rootfile');
    const rootfile = rootfileEl && (rootfileEl.getAttribute('full-path') || rootfileEl.getAttribute('fullpath'));
    if(!rootfile) throw new Error('Invalid EPUB: no rootfile');
    const opfDoc = parseXml(await readText(rootfile));
    const base = rootfile.split('/').slice(0,-1).join('/') + '/';

    let title = '', author = '';
    const metaEl = opfDoc.querySelector('package > metadata') || opfDoc.querySelector('metadata');
    if(metaEl){
      const kids = Array.from(metaEl.children);
      const tEl = kids.find(el => (el.localName||'').toLowerCase()==='title');
      if(tEl && tEl.textContent) title = (tEl.textContent || '').trim();
      const creators = kids.filter(el => (el.localName||'').toLowerCase()==='creator');
      if(creators && creators.length) author = creators.map(el=> (el.textContent||'').trim()).filter(Boolean).join(', ');
    }

    // Optional cover
    let coverUrl = '';
    try{
      // method 1: <meta name="cover" content="id">
      const metaCover = opfDoc.querySelector('meta[name="cover"]');
      let coverId = metaCover && metaCover.getAttribute('content');
      // method 2: manifest item with properties~="cover-image"
      const man = opfDoc.querySelector('manifest');
      let coverHref = '';
      if(man){
        if(!coverId){
          const coverItem = man.querySelector('item[properties~="cover-image"], item[id*="cover" i][href]');
          if(coverItem) coverHref = coverItem.getAttribute('href');
        } else {
          const itemEl = man.querySelector(`item[id="${CSS.escape(coverId)}"]`);
          if(itemEl) coverHref = itemEl.getAttribute('href');
        }
      }
      if(coverHref){
        const path = joinPath(base, coverHref);
        const file = zip.file(path) || zip.file(path.replace(/^\//,''));
        if(file){
          const b = await file.async('blob');
          coverUrl = URL.createObjectURL(b);
        }
      }
    }catch{}

    return { title, author, cover: coverUrl };
  }

    const zip = await JSZip.loadAsync(blob);
    async function readText(path){
      let f = zip.file(path) || zip.file(path && path.replace(/^\//,''));
      if(!f && path){ try{ f = zip.file(decodeURIComponent(path)); }catch{} }
      if(!f && path){ try{ f = zip.file(decodeURIComponent(path.replace(/^\//,''))); }catch{} }
      if(!f) return null; // gracefully signal missing
      return await f.async('string');
    }
    function joinPath(base, rel){
      if(!rel) return base;
      if(/^https?:|^data:|^blob:/.test(rel)) return rel;
      if(rel.startsWith('/')) return rel.slice(1); // zip root
      const stack = base.split('/'); stack.pop();
      for(const seg of rel.split('/')){
        if(!seg || seg==='.') continue;
        if(seg==='..') stack.pop(); else stack.push(seg);
      }
      return stack.join('/');
    }
    function parseXml(str){ return new DOMParser().parseFromString(str, 'application/xml'); }

    // container.xml → OPF path
    const containerDoc = parseXml(await readText('META-INF/container.xml'));
    const rootfileEl = containerDoc.querySelector('rootfile');
    const rootfile = rootfileEl && (rootfileEl.getAttribute('full-path') || rootfileEl.getAttribute('fullpath'));
    if(!rootfile) throw new Error('Invalid EPUB: container.xml missing rootfile');

    // Parse OPF
    const opfDoc = parseXml(await readText(rootfile));
    const base = rootfile.split('/').slice(0,-1).join('/') + '/';

    // Metadata: title
    let title = 'EPUB';
    let author = '';
    const metaEl = opfDoc.querySelector('package > metadata') || opfDoc.querySelector('metadata');
    if(metaEl){
      const kids = Array.from(metaEl.children);
      const tEl = kids.find(el => (el.localName||'').toLowerCase()==='title');
      if(tEl && tEl.textContent) title = tEl.textContent.trim() || title;
      const creators = kids.filter(el => (el.localName||'').toLowerCase()==='creator');
      if(creators && creators.length) author = creators.map(el=>el.textContent.trim()).filter(Boolean).join(', ');
    }
    if(item.title && item.title.length>0) title = item.title;
    if(item.author && item.author.length>0) author = item.author;

    // Manifest map id→href
    const manifest = {};
    (opfDoc.querySelectorAll('manifest > item') || []).forEach(it => {
      const id = it.getAttribute('id');
      const href = it.getAttribute('href');
      const mediaType = it.getAttribute('media-type') || it.getAttribute('mediaType');
      if(id && href) manifest[id] = { id, href, mediaType };
    });

    // Spine order
    const spineRefs = Array.from(opfDoc.querySelectorAll('spine > itemref')) || [];
    const viewer = document.getElementById('viewer');
    viewer.innerHTML='';
    let chapIndex = 0;

    for(const ref of spineRefs){
      const idref = ref.getAttribute('idref');
      const mf = manifest[idref];
      if(!mf) continue;
      const href = joinPath(base, mf.href);
      const xhtml = await readText(href);
      if(!xhtml) { console.warn('Missing spine doc', href); continue; }
      const doc = new DOMParser().parseFromString(xhtml, 'application/xhtml+xml');

      // Normalize images → blob URLs
      await Promise.all(Array.from(doc.querySelectorAll('img[src]')).map(async img=>{
        try{
          const src = img.getAttribute('src');
          const path = joinPath(href, src);
          let file = zip.file(path) || zip.file(path.replace(/^\//,''));
          if(file){
            const b = await file.async('blob');
            const url = URL.createObjectURL(b);
            img.setAttribute('src', url);
          }
        }catch{}
      }));

      // Preprocess hyperlinks (internal vs external)
      Array.from(doc.querySelectorAll('a[href]')).forEach(a=>{
        const raw = a.getAttribute('href');
        if(!raw) return;
        if(/^https?:|^mailto:|^tel:/i.test(raw)){
          a.setAttribute('target','_blank'); a.setAttribute('rel','noopener noreferrer'); return;
        }
        // make absolute to current chapter
        let abs = raw.startsWith('#') ? (href + raw) : (function(){
          const u = raw.replace(/^\/+/, '');
          return joinPath(href, u);
        })();
        let path = abs, frag = '';
        const hi = abs.indexOf('#'); if(hi>=0){ path = abs.slice(0,hi); frag = abs.slice(hi+1); }
        a.setAttribute('data-ep-path', path.replace(/^\/+/,''));
        if(frag) a.setAttribute('data-ep-frag', frag);
      });

      // Append body to viewer
      const sec = document.createElement('section');
      sec.setAttribute('data-chapter', String(++chapIndex));
      sec.setAttribute('data-src', href);
      Array.from(doc.body.childNodes).forEach(n => sec.appendChild(document.importNode(n, true)));
      viewer.appendChild(sec);
    }

    const titleEl = document.getElementById('bookTitle');
    if(titleEl) titleEl.textContent = [title, author].filter(Boolean).join(' - ');

    
    // Persist metadata on the item/app model for consistency
    try{
      item.title = title || item.title || '';
      item.author = author || item.author || '';
      const model = app.byId && app.byId.get(item.id);
      if(model){ model.title = item.title; model.author = item.author; }
    }catch{}// Reset reading state (align with your existing code expectations)
    if(window.state){
      window.state.currentBook = { id: item.id, type:'epub', title, author, bookmarks:[], lastPercent:0 };
      window.scrollTo({top:0, behavior:'instant'});
      try{ window.onScroll && window.onScroll(); }catch{}
      try{ window.buildTOC && window.buildTOC(); }catch{}
    }
  }

  
  // Delegate internal link navigation inside the viewer
  if(!window.__viewerLinkHandler){
    const vroot = document.getElementById('viewer');
    if(vroot){
      vroot.addEventListener('click', function(e){
        const a = e.target.closest && e.target.closest('a[href]');
        if(!a) return;
        const raw = a.getAttribute('href') || '';
        if(/^https?:|^mailto:|^tel:/i.test(raw)) return; // external: allow default
        e.preventDefault();
        const path = a.getAttribute('data-ep-path') || (a.closest('section[data-src]')?.getAttribute('data-src') || '');
        const frag = a.getAttribute('data-ep-frag') || (raw.startsWith('#') ? raw.slice(1) : '');
        // find section with matching data-src (strip leading slashes for safety)
        const canon = (path || '').replace(/^\/+/, '');
        let section = document.querySelector(`section[data-src="${canon}"]`) || document.querySelector(`section[data-src="${path}"]`);
        if(section){
          const target = frag ? section.querySelector('#'+CSS.escape(frag)) : section;
          (target || section).scrollIntoView({behavior:'smooth', block:'start'});
        }
      }, {capture:false});
      window.__viewerLinkHandler = true;
    }
  }

  // Init

  (async function init(){
    // Default route
    if(!location.hash) location.replace('#/login');
    // Load bundled manifest if present
    await tryLoadManifest();
    renderLibrary();
    route();
  })();
})();
</script><script id="patch-stage1-progress-top">
(function(){
      const topbar = document.getElementById('topbar') || document.querySelector('.topbar');
      const progressWrap = document.getElementById('progressWrap');
      if(topbar && progressWrap){
        function adjustProgressTop(){
          const h = topbar.offsetHeight || 0;
          progressWrap.style.top = h + 'px';
          document.documentElement.style.setProperty('--progress-top', h + 'px');
        }
        window.addEventListener('resize', adjustProgressTop, {passive:true});
        document.addEventListener('DOMContentLoaded', adjustProgressTop);
        adjustProgressTop();
      }
    })();
</script><script id="patch-stage3-annot-guard">
window.__squelchSel = window.__squelchSel || false;
</script>
<script id="toc-builder">
(function(){
  'use strict';
  const viewer = document.getElementById('viewer');
  const tocRoot = document.getElementById('drawerTOC');
  if(!viewer || !tocRoot) return;

  function ensureId(el, prefix){
    if(el.id && el.id.length) return el.id;
    const id = (prefix||'toc') + '-' + Math.random().toString(36).slice(2);
    el.id = id;
    return id;
  }

  function collectHeadings(){
    const hs = Array.from(viewer.querySelectorAll('h1, h2, h3, h4, h5, h6'));
    if(hs.length) {
      return hs.map(h => ({
        el: h,
        id: ensureId(h, 'h'),
        text: (h.textContent || '').trim().replace(/\s+/g,' ').slice(0,160),
        level: Math.min(6, Math.max(1, parseInt(h.tagName[1], 10) || 2))
      }));
    }
    // Fallback: per section; or if no sections, just top of the document
    const secs = Array.from(viewer.querySelectorAll('section[data-chapter]'));
    if(secs.length){
      return secs.map((sec, i) => {
        const probe = sec.querySelector('h1,h2,h3,h4,h5,h6,p,li,blockquote,figure,table');
        let text = (probe && (probe.textContent || '').trim()) || 'Chapter ' + (i+1);
        text = text.replace(/\s+/g,' ').slice(0,160);
        return { el: sec, id: ensureId(sec, 'sec'), text, level: 2 };
      });
    }
    // Single "Start" item targeting the viewer root
    return [{ el: viewer, id: ensureId(viewer, 'doc'), text: 'Start', level: 1 }];
  }

  function buildTOC(){
    const items = collectHeadings();
    tocRoot.innerHTML = '';
    const scroll = document.createElement('div');
    scroll.className = 'toc-scroll';
    items.forEach(it => {
      const div = document.createElement('div');
      div.className = 'toc-item lvl-' + it.level;
      div.textContent = it.text || '(untitled)';
      div.dataset.targetId = it.id;
      div.addEventListener('click', () => {
        const t = document.getElementById(it.id);
        if(t) t.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
      scroll.appendChild(div);
    });
    tocRoot.appendChild(scroll);

    // Highlight active item based on viewport position
    try{
      const mapping = new Map();
      Array.from(scroll.children).forEach((node, i) => mapping.set(items[i].el, node));
      const io = new IntersectionObserver((entries) => {
        let best = null;
        for(const en of entries){
          if(!en.isIntersecting) continue;
          const r = en.intersectionRatio;
          if(!best || r > best.r) best = { el: en.target, r };
        }
        if(best){
          const node = mapping.get(best.el);
          if(node){
            scroll.querySelectorAll('.toc-item.toc-active').forEach(n => n.classList.remove('toc-active'));
            node.classList.add('toc-active');
            window.__tocActiveText = node.textContent || '';
            try{ window.dispatchEvent(new CustomEvent('toc-active-change', { detail: { text: window.__tocActiveText } })); }catch(_){}

            // auto-scroll inside the toc to keep active in view
            const cr = scroll.getBoundingClientRect();
            const nr = node.getBoundingClientRect();
            if(nr.top < cr.top || nr.bottom > cr.bottom){
              scroll.scrollTo({ top: node.offsetTop - 60, behavior: 'smooth' });
            }
          }
        }
      }, { root: null, rootMargin: '-30% 0px -60% 0px', threshold: [0, .25, .5, .75, 1] });

      // Observe headings or fallback targets
      items.forEach(it => io.observe(it.el));
    }catch(_){ /* graceful */ }
  }

  // Expose and build initially
  window.buildTOC = buildTOC;
  // Build on DOM ready (for demo content) and on hash changes (after routing), and when drawer opens
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', buildTOC, { once: true });
  else buildTOC();

  // Rebuild TOC whenever the viewer content changes significantly
  try{
    const mo = new MutationObserver((mut) => {
      // If nodes added/removed under viewer, rebuild after a tick
      clearTimeout(window.__tocRebuildTick);
      window.__tocRebuildTick = setTimeout(buildTOC, 50);
    });
    mo.observe(viewer, { childList: true, subtree: true });
  }catch(_){}

  // Listen for a custom event in case other modules want to trigger a rebuild
  document.addEventListener('rebuild-toc', buildTOC);
})();
</script>


<script id="drawer-controls-inject-svg">
(function(){
  const root = document.getElementById('drawerAnno');
  if(!root) return;
  const ns = 'http://www.w3.org/2000/svg';
  root.querySelectorAll('.drawer-controls label').forEach(label => {
    const input = label.querySelector('input[type="checkbox"]');
    if(!input) return;
    if(label.querySelector('.tick')) return; // already added
    const svg = document.createElementNS(ns, 'svg');
    svg.setAttribute('class','tick');
    svg.setAttribute('viewBox','0 0 20 20');
    const rect = document.createElementNS(ns, 'rect');
    rect.setAttribute('x','1'); rect.setAttribute('y','1');
    rect.setAttribute('width','18'); rect.setAttribute('height','18'); rect.setAttribute('rx','4');
    const path = document.createElementNS(ns, 'path');
    path.setAttribute('d','M5 10.5 L8.5 14 L15 6');
    svg.appendChild(rect); svg.appendChild(path);
    input.after(svg);
  });
})();
</script>



<script id="title-toggle-subheading">
(function(){
  'use strict';
  var titleEl = document.getElementById('bookTitle');
  if(!titleEl) return;

  // Current mode: 'book' shows full book title; 'sub' shows current section/subheading
  var mode = 'book';

  function getActiveTOCText(){
    try{
      var toc = document.getElementById('drawerTOC');
      var active = toc && toc.querySelector('.toc-item.toc-active');
      if(active) return (active.textContent || '').trim();
    }catch(_){}
    return (window.__tocActiveText || '').trim();
  }

  function syncPageTitle(){
    var t = (titleEl.textContent || '').trim();
    if(t) { try { document.title = t; } catch(_){} }
  }

  function setMode(next){
    mode = next === 'sub' ? 'sub' : 'book';
    document.documentElement.setAttribute('data-title-mode', mode);
    if(mode === 'sub'){
      var t = getActiveTOCText();
      if(t) titleEl.textContent = t;
    } else {
      if(typeof window.__bookTitleFull === 'string' && window.__bookTitleFull.length){
        titleEl.textContent = window.__bookTitleFull;
      }
    }
    // Always reflect top-bar text to the page <title>
    syncPageTitle();
  }

  function toggle(){
    setMode(mode === 'book' ? 'sub' : 'book');
  }

  // Clicking the title toggles the mode
  titleEl.addEventListener('click', function(ev){
    try{ ev.stopPropagation(); }catch(_){}
    toggle();
  }, false);

  // Keep title synced while in 'sub' mode
  window.addEventListener('toc-active-change', function(ev){
    if(mode !== 'sub') return;
    var txt = (ev && ev.detail && ev.detail.text) || getActiveTOCText();
    if(txt) {
      titleEl.textContent = (txt || '').trim();
      syncPageTitle();
    }
  });

  // Track and remember the full book title whenever it changes (only in 'book' mode)
  var mo = new MutationObserver(function(){
    var t = (titleEl.textContent || '').trim();
    if(mode === 'book' && t){
      window.__bookTitleFull = t;
    }
    // Regardless of mode, ensure the browser tab title mirrors the visible top-bar text
    syncPageTitle();
  });
  try{
    mo.observe(titleEl, { characterData: true, subtree: true, childList: true });
  }catch(_){}

  // Initialize remembered book title and set <title> on first run
  if(titleEl.textContent) window.__bookTitleFull = (titleEl.textContent || '').trim();
  syncPageTitle();

  // Expose helpers (optional)
  window.setTitleMode = setMode;
  window.getTitleMode = function(){ return mode; };
})();
</script>


</body>
</html>
